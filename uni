#!/usr/bin/env php
<?php


namespace Output {






interface OutputInterface
{
    public function write($msg, $lbr = true);
}







interface ProgramOutputInterface extends OutputInterface
{
    public function success($msg, $lbr = true);
    public function error($msg, $lbr = true);
    public function warn($msg, $lbr = true);
    public function info($msg, $lbr = true);
    public function notice($msg, $lbr = true);
    public function debug($msg, $lbr = true);
}







class Output implements OutputInterface
{
    public function write($msg, $lbr = true)
    {
        echo $msg;
        if (true === $lbr) {
            echo PHP_EOL;
        }
    }

}







/**
 *
 * This output is made for a cli program.
 *
 *
 *
 * Foreground
 * ----------------
 * black: 0;30
 * blue: 0;34
 * green: 0;32
 * cyan: 0;36    (light blue)
 * red: 0;31
 * purple: 0;35
 * brown: 0;33
 * yellow: 1;33
 * light gray: 0;37
 * white: 1;37
 *
 *
 * dark gray: 1;30
 * light blue: 1;34
 * light green: 1;32
 * light cyan: 1;36
 * light red: 1;31
 * light purple: 1;35
 * light gray: 0;37
 *
 *
 * Background
 * ----------------
 * black: 40
 * red: 41
 * green: 42
 * yellow: 43
 * blue: 44
 * magenta: 45
 * cyan: 46
 * light gray: 47
 *
 */
class ProgramOutput extends Output implements ProgramOutputInterface
{

    private $dampened;

    public function __construct()
    {
        $this->dampened = [];
    }

    public static function create()
    {
        return new static();
    }

    public function success($msg, $lbr = true)
    {
        $this->writeMessage('success', $msg, "0;32", $lbr);
    }

    public function error($msg, $lbr = true)
    {
        $this->writeMessage('error', $msg, "0;31", $lbr);
    }

    public function warn($msg, $lbr = true)
    {
        $this->writeMessage('warn', $msg, "1;31", $lbr);
    }

    public function info($msg, $lbr = true)
    {
        $this->writeMessage('info', $msg, "0;34", $lbr);
    }

    public function notice($msg, $lbr = true)
    {
        $this->writeMessage('notice', $msg, "0;30", $lbr);
    }

    public function debug($msg, $lbr = true)
    {
        $this->writeMessage('debug', $msg, "0;33", $lbr);
    }
    //--------------------------------------------
    //
    //--------------------------------------------
    public function setDampened(array $dampened)
    {
        $this->dampened = $dampened;
        return $this;
    }

    //--------------------------------------------
    //
    //--------------------------------------------
    private function writeMessage($type, $msg, $colorCode, $lbr = true)
    {
        // is dampened?
        if (in_array($type, $this->dampened, true)) {
            return;
        }
        $msg = "\e[" . $colorCode . "m$msg\e[0m";
        $this->write($msg, $lbr);
    }

}







interface ProgramOutputAwareInterface
{
    public function setProgramOutput(ProgramOutputInterface $output);
}

}
// ------------------------------

namespace CopyDir\Exception {




/*
 * LingTalfi 2015-10-19
 */


class CopyDirException extends \Exception
{


    public $errorArray;

    public function __construct($message = "", $code = 0, \Exception $previous = null)
    {
        parent::__construct($message, $code, $previous);
        $this->errorArray = [];
    }


}

}
// ------------------------------

namespace CopyDir {




/*
 * LingTalfi 2015-10-19
 */
use CopyDir\Exception\CopyDirException;

class CopyDirUtil
{

    /**
     * @var bool: if true, throws an exception if anything goes wrong
     *            if false (default), put errors in the errors array
     */
    private $strictMode;
    private $errors;
    private $followFileLinks;
    private $followDirLinks;

    /**
     *    void      f (  str:src,  str:target,  &str:errMsg )
     *
     * This callback is called whenever we try to make a copy of a dir to an already existing
     * entry which is either a file or a broken link.
     *
     * The default behaviour, if the callback is not defined (or do nothing) is to skip the copying of the
     * directory and to add an error message indicating that an entry with the same name already existed.
     *
     * The callback has the opportunity to change this behaviour by changing the errMsg that will be produced,
     * and/or by removing the existing entry and create a valid directory instead.
     * Once the callback has been executed, the class will re-check whether or not a directory exist,
     * and will use the new directory if found.
     *
     * If the directory has been recreated, the errMsg should be the empty string.
     *
     *
     */
    private $onDirConflict;

    /**
     * Same mechanism as onDirConflict, except that the target can be any type of file (file, symlink, dir).
     * And also, there is no double checking that the file exists after the callback is called, the class
     * just cares about the errMsg which can be either non empty or empty.
     */
    private $onFileConflict;
    private $onFileLinkConflict;
    private $onDirLinkConflict;
    private $onBrokenLinkConflict;

    /**
     * void     f ( str:baseName, str:src, str:target, bool:&continue=true )
     *
     * This callback is triggered before directory entries are processed.
     * It was originally designed to serve as a pre-filter (to filter out undesirable entries).
     *
     * If the callback sets the continue flag to false, the entry will be skip.
     *
     *
     */
    private $onCopyBefore;
    /**
     * void     f ( str:src, str:target )
     *
     * This callback is triggered:
     * - every time a src directory is mapped to a target directory
     * - every time a try to copy a src directory entry into its target correspondent is done
     *
     * This callback was originally designed to allow post chmoding of the target entries.
     *
     */
    private $onCopyAfter;

    public function __construct()
    {
        $this->strictMode = false;
        $this->errors = [];
        $this->followFileLinks = false;
        $this->followDirLinks = false;
        $this->onDirConflict = false;
        $this->onFileConflict = false;
        $this->onFileLinkConflict = false;
        $this->onDirLinkConflict = false;
        $this->onBrokenLinkConflict = false;
        $this->onCopyBefore = false;
        $this->onCopyAfter = false;
    }


    public static function create()
    {
        return new static();
    }


    /**
     * Copies/maps src to target.
     *
     * @return true if no error occurred, false otherwise,
     *              or throws an exception if an error occurs and strict mode is on (strict mode is on by default).
     * @throws CopyDirException
     */
    public function copyDir($src, $target)
    {
        if (2 === func_num_args()) {
            $this->errors = [];
        }

        if (is_dir($src)) {
            if (is_readable($src)) {

                $cleanTarget = true;
                // case where the target is a file or a broken link (it's supposed to be either a file or not exist)
                if (
                    is_file($target) ||
                    (is_link($target) && (false === is_file($target) && false === is_dir($target)))
                ) {
                    $errMsg = "Cannot create dir $target, because an entry (of type file or broken link) with the same name was already found";
                    if (is_callable($this->onDirConflict)) {
                        call_user_func_array($this->onDirConflict, [$src, $target, &$errMsg]);
                    }
                    clearstatcache(); // not sure if needed for is_dir($target) call, so in doubt...
                    if (!is_dir($target)) {
                        $cleanTarget = false;
                    }
                    if ($errMsg) {
                        $this->error($errMsg);
                    }
                }


                if (true === $cleanTarget) {

                    $targetIsDir = true;
                    if (!is_dir($target)) {
                        if (false === mkdir($target, 0777, true)) {
                            $this->error("Couldn't create the target dir: $target");
                            $targetIsDir = false;
                        }
                    }
                    if (true === $targetIsDir) {

                        $this->_onCopyAfter($src, $target);


                        if (is_writable($target)) {
                            $files = scandir($src);
                            foreach ($files as $baseName) {
                                if ('.' !== $baseName && '..' !== $baseName) {


                                    $file = $src . '/' . $baseName;
                                    $targetFile = $target . '/' . $baseName;


                                    $continue = true;
                                    if (is_callable($this->onCopyBefore)) {
                                        call_user_func_array($this->onCopyBefore, [$baseName, $file, $targetFile, &$continue]);
                                    }


                                    if (true === $continue) {

                                        $isProcessedAsLink = false;
                                        if (is_link($file)) {
                                            if (is_file($file)) {
                                                if (false === $this->followFileLinks) {
                                                    $isProcessedAsLink = true;
                                                    $this->copyFileLink($file, $targetFile);
                                                }
                                            }
                                            elseif (is_dir($file)) {
                                                if (false === $this->followDirLinks) {
                                                    $isProcessedAsLink = true;
                                                    $this->copyDirLink($file, $targetFile);
                                                }
                                            }
                                            else {
                                                // broken link
                                                $isProcessedAsLink = true;
                                                $this->copyBrokenLink($file, $targetFile);
                                            }
                                        }


                                        if (false === $isProcessedAsLink) {
                                            if (is_file($file)) {
                                                $this->copyFile($file, $targetFile);
                                            }
                                            elseif (is_dir($file)) {
                                                $this->copyDir($file, $targetFile, true);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            $this->error("Target dir must be writable: $target");
                        }
                    }
                }
            }
            else {
                $this->error("src is not readable: $src");
            }
        }
        else {
            $this->error("src is not a dir: $src");
        }


        // handling errors
        if (true === $this->strictMode && $this->errors) {
            $m = 'The following errors have occurred: ' . implode(', ', $this->errors);
            $e = new CopyDirException($m);
            $e->errorArray = $this->errors;
            throw $e;
        }
        return (0 === count($this->errors));
    }



    //------------------------------------------------------------------------------/
    // 
    //------------------------------------------------------------------------------/
    public function setStrictMode($strictMode)
    {
        $this->strictMode = (bool)$strictMode;
        return $this;
    }

    public function getErrors()
    {
        return $this->errors;
    }

    public function setFollowDirLinks($followDirLinks)
    {
        $this->followDirLinks = (bool)$followDirLinks;
        return $this;
    }

    public function setFollowFileLinks($followFileLinks)
    {
        $this->followFileLinks = (bool)$followFileLinks;
        return $this;
    }

    public function setOnBrokenLinkConflict($onBrokenLinkConflict)
    {
        $this->onBrokenLinkConflict = $onBrokenLinkConflict;
        return $this;
    }

    public function setOnCopyAfter($onCopyAfter)
    {
        $this->onCopyAfter = $onCopyAfter;
        return $this;
    }

    public function setOnCopyBefore($onCopyBefore)
    {
        $this->onCopyBefore = $onCopyBefore;
        return $this;
    }

    public function setOnDirConflict($onDirConflict)
    {
        $this->onDirConflict = $onDirConflict;
        return $this;
    }

    public function setOnDirLinkConflict($onDirLinkConflict)
    {
        $this->onDirLinkConflict = $onDirLinkConflict;
        return $this;
    }

    public function setOnFileConflict($onFileConflict)
    {
        $this->onFileConflict = $onFileConflict;
        return $this;
    }

    public function setOnFileLinkConflict($onFileLinkConflict)
    {
        $this->onFileLinkConflict = $onFileLinkConflict;
        return $this;
    }



    //------------------------------------------------------------------------------/
    // 
    //------------------------------------------------------------------------------/
    private function copyFile($src, $target)
    {
        $this->copyThing($src, $target, "file", "onFileConflict");
    }

    private function copyFileLink($src, $target)
    {
        $this->copyThing($src, $target, "file link", "onFileLinkConflict");
    }

    private function copyDirLink($src, $target)
    {
        $this->copyThing($src, $target, "dir link", "onDirLinkConflict");
    }

    private function copyBrokenLink($src, $target)
    {
        $this->copyThing($src, $target, "broken link", "onBrokenLinkConflict");
    }


    private function copyThing($src, $target, $type, $callback)
    {
        if (!file_exists($target) && !is_link($target)) {
            switch ($type) {
                case 'dir link':
                case 'file link':
                case 'broken link':
                    $link = readlink($src);
                    if (false === symlink($link, $target)) {
                        $this->error("Could not copy $type $src to $target");
                    }
                    break;
                default:
                    if (false === copy($src, $target)) {
                        $this->error("Could not copy $type $src to $target");
                    }
                    break;
            }
        }
        else {
            $errMsg = "Couldn't create $type $target, because an entry with the same name already existed";
            $this->onConflict($src, $target, $errMsg, $callback, $type);
            if ($errMsg) {
                $this->error($errMsg);
            }
        }
        $this->_onCopyAfter($src, $target);
    }


    //------------------------------------------------------------------------------/
    // 
    //------------------------------------------------------------------------------/
    protected function onConflict($src, $target, &$errMsg, $callback, $type)
    {
        if (is_callable($this->$callback)) {
            call_user_func_array($this->$callback, [$src, $target, &$errMsg]);
        }
    }


    protected function _onCopyAfter($src, $target)
    {
        if (is_callable($this->onCopyAfter)) {
            call_user_func($this->onCopyAfter, $src, $target);
        }
    }

    protected function error($m)
    {
        $this->errors[] = $m;
    }
}





/*
 * LingTalfi 2015-10-19
 * 
 * Features:
 * - on file conflict: if the target is a file, its content gets replaced with
 *          the content of the src. 
 * - by default ignore conflict errors
 * - can handle mapping of permissions
 * 
 * 
 */

class AuthorCopyDirUtil extends CopyDirUtil
{

    private $applyPerms;
    private $applyOwner;
    private $ignoreConflictErrors;

    public function __construct()
    {
        parent::__construct();
        $this->applyOwner = false;
        $this->applyPerms = false;
        $this->ignoreConflictErrors = true;
    }

    public function setPreservePerms($bool)
    {
        $bool = (bool)$bool;
        $this->applyOwner = $bool;
        $this->applyPerms = $bool;
        return $this;
    }

    public function setIgnoreConflictErrors($ignoreConflictErrors)
    {
        $this->ignoreConflictErrors = (bool)$ignoreConflictErrors;
        return $this;
    }






    //------------------------------------------------------------------------------/
    // 
    //------------------------------------------------------------------------------/
    protected function onConflict($src, $target, &$errMsg, $callback, $type)
    {
        if ('onFileConflict' === $callback) {
            if (is_file($target)) {
                copy($src, $target);
                $errMsg = null;
            }
        }
        if (true === $this->ignoreConflictErrors) {
            $errMsg = null;
        }
        parent::onConflict($src, $target, $errMsg, $callback, $type);
    }

    protected function _onCopyAfter($src, $target)
    {
        if (is_link($src) && false === is_file($src) && false === is_dir($src)) {
            // broken link case, we don't need to chmod it
        }
        else {
            if (true === $this->applyPerms) {
                $octal = substr(sprintf('%o', fileperms($src)), -4);
                if (false === chmod($target, octdec($octal))) {
                    $this->error("Cannot chmod $target with perms $octal");
                }
            }
            if (true === $this->applyOwner) {
                if (false !== ($owner = fileowner($src))) {
                    if (false !== ($ownerGroup = filegroup($src))) {
                        if (false === chown($target, $owner)) {
                            if (true === extension_loaded('posix')) {
                                $owner = posix_getpwuid($owner)['name'];
                            }
                            $this->error("Could not chown for $target with owner=$owner");
                        }
                        if (false === chgrp($target, $ownerGroup)) {
                            if (true === extension_loaded('posix')) {
                                $ownerGroup = posix_getgrgid($ownerGroup)['name'];
                            }
                            $this->error("Could not chgrp for $target with owner=$ownerGroup");
                        }

                    }
                    else {
                        $this->error("Couldn't access group owner information for $src");
                    }
                }
                else {
                    $this->error("Couldn't access file owner information for $src");
                }
            }
        }
        parent::_onCopyAfter($src, $target);
    }


}

}
// ------------------------------

namespace Bat {






use CopyDir\AuthorCopyDirUtil;

class FileSystemTool
{

    /**
     * Removes an entry from the filesystem.
     * The entry can be:
     *
     * - a link, then the link only is removed (not the target)
     * - a file, then the file is removed
     * - a directory, the the directory is removed recursively
     *
     * It is considered a success when the entry doesn't exist on the filesystem at the end,
     * and a failure otherwise.
     *
     * By default, the method throws an exception in case of failure.
     *
     * If you set the throwEx flag to false, then this method will return true in case of success,
     * and false in case of failure.
     *
     */
    public static function remove($file, $throwEx = true)
    {
        if (false === is_link($file)) {
            if (file_exists($file)) {
                return self::_remove($file, $throwEx);
            } else {
                return true;
            }
        } else {
            if (false === unlink($file)) {
                return self::_oops("Cannot remove link $file", $throwEx);
            }
            return true;
        }
    }

    /**
     * Copies a directory to a given location.
     */
    public static function copyDir($src, $target, $preservePerms = false, &$errors = [])
    {
        $o = AuthorCopyDirUtil::create();
        $o->setPreservePerms($preservePerms);
        $ret = $o->copyDir($src, $target);
        $errors = $o->getErrors();
        return $ret;
    }




    //------------------------------------------------------------------------------/
    //
    //------------------------------------------------------------------------------/
    private static function _oops($m, $throwEx = true)
    {
        if (true === $throwEx) {
            throw new \Exception($m);
        }
        return false;
    }

    private static function _remove($file, $throwEx = true)
    {
        if (is_dir($file) && !is_link($file)) {
            if (is_readable($file)) {
                $files = new \FilesystemIterator($file,
                    \FilesystemIterator::KEY_AS_PATHNAME |
                    \FilesystemIterator::CURRENT_AS_FILEINFO |
                    \FilesystemIterator::SKIP_DOTS
                );
                foreach ($files as $f) {
                    self::_remove($f, $throwEx);
                }
                if (false === rmdir($file)) {
                    return self::_oops("Cannot remove dir $file", $throwEx);
                }
                return true;
            } else {
                return self::_oops("Cannot remove unreadable dir $file", $throwEx);
            }
        } else {
            if (true === is_file($file) || true === is_link($file)) {
                if (false === unlink($file)) {
                    if (true === is_link($file)) {
                        return self::_oops("Cannot remove link $file", $throwEx);
                    }
                    return self::_oops("Cannot remove file $file", $throwEx);
                }
                return true;
            }
        }
    }
}

}
// ------------------------------

namespace Tools {






use Bat\FileSystemTool;
use Output\ProgramOutputInterface;

class CleanerTool
{
    /**
     * @var ProgramOutputInterface $output
     */
    private $filesToBeCleaned;
    private $dirsToBeCleaned;
    private $useSymlinks;

    public function __construct()
    {
        $this->filesToBeCleaned = [
            '.gitignore',
            '.DS_Store',
        ];
        $this->dirsToBeCleaned = [
            '.idea',
            '.git',
        ];
        $this->useSymlinks = false;
    }

    public static function create()
    {
        return new static();
    }

    public function setFilesToBeCleaned($filesToBeCleaned)
    {
        $this->filesToBeCleaned = $filesToBeCleaned;
        return $this;
    }

    public function setDirsToBeCleaned($dirsToBeCleaned)
    {
        $this->dirsToBeCleaned = $dirsToBeCleaned;
        return $this;
    }


    public function clean($targetDir, $recursive = false)
    {
        if (file_exists($targetDir)) {

            $items = $this->getPlanetNames($targetDir);
            foreach ($items as $item) {
                $d = $targetDir . "/" . $item;
                $this->cleanDir($d, $recursive);
            }
        } else {
            throw new \RuntimeException("target directory does not exist: $targetDir");
        }
    }


    //--------------------------------------------
    //
    //--------------------------------------------
    private function cleanDir($dir, $recursive = false)
    {
        if (false === $this->useSymlinks && is_link($dir)) {
            return;
        }
        foreach ($this->filesToBeCleaned as $_f) {
            $f = $dir . "/$_f";
            if (file_exists($f)) {
                if (false === $this->useSymlinks && is_link($f)) {
                    continue;
                }
                unlink($f);
            }
        }
        foreach ($this->dirsToBeCleaned as $_f) {
            $f = $dir . "/$_f";
            if (is_dir($f)) {
                if (false === $this->useSymlinks && is_link($f)) {
                    continue;
                }
                FileSystemTool::remove($f);
            }
        }

        if (true === $recursive) {
            $files = scandir($dir);
            foreach ($files as $f) {
                if ('.' !== $f && '..' !== $f) {
                    $file = $dir . "/" . $f;
                    if (is_dir($file)) {
                        if (false === $this->useSymlinks && is_link($file)) {
                            continue;
                        }
                        $this->cleanDir($file, $recursive);
                    }
                }
            }
        }
    }



    //--------------------------------------------
    //
    //--------------------------------------------
    private function getPlanetNames($planetsDir)
    {

        $files = scandir($planetsDir);
        return array_filter($files, function ($v) use ($planetsDir) {
            if (false !== strpos($v, '.')) {
                return false;
            }
            return is_dir($planetsDir . "/" . $v);
        });
    }
}










class SymlinkDirTool
{
    /**
     * @var ProgramOutputInterface $output
     */
    private $output;


    public static function create()
    {
        return new static();
    }


    public function setOutput(ProgramOutputInterface $output)
    {
        $this->output = $output;
        return $this;
    }


    public function convert($mode, $targetPlanetsDir, $localUniversePlanetsDir)
    {
        $output = $this->output;

        if (file_exists($targetPlanetsDir)) {
            if (file_exists($localUniversePlanetsDir)) {


                $planets = $this->getPlanetNames($targetPlanetsDir);


                foreach ($planets as $planet) {


                    $oldFile = $targetPlanetsDir . "/$planet";
                    $sourcePlanetDir = $localUniversePlanetsDir . "/$planet";
                    if (is_dir($sourcePlanetDir)) {


                        // remove old files (yes, it's risky)
                        if (file_exists($oldFile)) {
                            if (is_link($oldFile)) {
                                unlink($oldFile);
                            } else {
                                FileSystemTool::remove($oldFile);
                            }
                        }


                        if ('symlink' === $mode) {
                            symlink($sourcePlanetDir, $oldFile);
                        } else { // dir
                            FileSystemTool::copyDir($sourcePlanetDir, $oldFile);
                        }
                    } else {
                        $output->warn("local universe's planet directory does not exist: $sourcePlanetDir. No action was taken for that planet");
                    }
                }
            } else {
                $output->error("local universe's planets directory does not exist: $localUniversePlanetsDir");
            }

        } else {
            $output->error("target planets directory does not exist: $targetPlanetsDir");
        }
    }


    //--------------------------------------------
    //
    //--------------------------------------------
    private function getPlanetNames($planetsDir)
    {

        $files = scandir($planetsDir);
        return array_filter($files, function ($v) {
            if (false !== strpos($v, '.')) {
                return false;
            }
            return true;
        });
    }

}

}
// ------------------------------

namespace UniverseNaiveImporter\Importer {





/**
 *
 * An universe importer can import all planets and dependencies of a given universe.
 *
 */
interface UniverseImporterInterface
{

    public function getName();


    public function canImport($planetName);

    public function getUniverse();

    /**
     * Import the given planet to the planets directory.
     * If the directory already exists, it does nothing.
     */
    public function import($planetName, $planetsDir);


    /**
     * @return array of items.
     * Each item is an array with three entries:
     *      - 0: the planet name
     *      - 1: the description of the planet
     */
    public function getAvailablePlanets();


    /**
     * @return array of flattened (cycling references resolved) dependencies for the given planet;
     * the dependency tree includes the given planetName itself.
     *
     * The order is not considered important.
     */
    public function getDependencyTree($planetName);
}







abstract class AbstractGithubUniverseImporter implements UniverseImporterInterface
{

    private $githubRepoName;


    public function __construct()
    {
        $this->githubRepoName = $this->getGithubRepositoryName();
    }

    public static function create()
    {
        return new static();
    }

    public function canImport($planetName)
    {
        return array_key_exists($planetName, $this->getDependencyMap());
    }


    public function import($planetName, $planetsDir)
    {
        $output = [];
        $returnVar = 0;
        $cmd = 'cd "' . $planetsDir . '"; git clone https://github.com/' . $this->githubRepoName . '/' . $planetName . '.git';
        exec($cmd, $output, $returnVar);

        if (0 === $returnVar) {
            return true;
        } else {
            return false;
        }
    }

    public function getAvailablePlanets()
    {
        $ret = [];
        $dependencyMap = $this->getDependencyMap();
        foreach ($dependencyMap as $planet => $deps) {
            $description = $this->getDescription($planet);
            $ret[] = [
                $planet,
                $description,
            ];
        }
        return $ret;
    }

    public function getDependencyTree($planetName)
    {
        $tree = [];
        $this->collectDependencyTree($planetName, $tree);
        $tree = array_unique($tree);
        return $tree;
    }



    //--------------------------------------------
    // OVERRIDE THOSE METHODS
    //--------------------------------------------
    protected function getDependencyMap()
    {
        return [];
    }

    protected function getDescription($planet)
    {
        return "";
    }

    protected function getGithubRepositoryName()
    {
        throw new \Exception("Override this method");
    }




    //--------------------------------------------
    //
    //--------------------------------------------
    private function collectDependencyTree($planets, array &$tree)
    {
        $dependencyMap = $this->getDependencyMap();
        if (is_string($planets)) {
            $moduleName = $planets;
            $tree[] = $moduleName;
            if (array_key_exists($moduleName, $dependencyMap)) {
                $deps = $dependencyMap[$moduleName];
                foreach ($deps as $dep) {
                    if (!in_array($dep, $tree, true)) {
                        $this->collectDependencyTree($dep, $tree);
                    }
                }
            }
        } elseif (is_array($planets)) {
            foreach ($planets as $moduleName) {
                $this->collectDependencyTree($moduleName, $tree);
            }
        }
    }
}







class LingUniverseImporter extends AbstractGithubUniverseImporter
{

    protected function getDependencyMap()
    {
        return [
            "AdminTable" => ["QuickPdo"],
            "ApplicationItemManager" => ["Bat", "Output", "Program", "CommandLineInput"],
            "ApplicationLog" => ["Bat"],
            "ArrayExport" => ["ArrayToString"],
            "ArrayStore" => ["ArrayExport", "Bat"],
            "ArrayToString" => [],
            "ArrayToTable" => ["Bat"],
            "AssetLoader" => [],
            "AssetsList" => ["Bat"],
            "BabyDash" => ["IndentedLines"],
            "BabyYaml" => ["Bat"],
            "Bat" => ["CopyDir", "Tiphaine"],
            "Bate" => ["Bat"],
            "Beauty" => ["DirScanner"],
            "BullSheet" => ["Bat", "DirScanner", "QuickPdo"],
            "BumbleBee" => [],
            "Colis" => ["Bat", "YouTubeUtils", "Tim", "UploaderHandler"],
            "CommandLineInput" => ["Output"],
            "CommandLineManiac" => [],
            "ConventionGuy" => [],
            "ConsoleTool" => [],
            "CopyDir" => [],
            "Csv" => [],
            "DirScanner" => ["Bat"],
            "DirTransformer" => ["Bat"],
            "Dreamer" => [],
            "Escaper" => ["Bat"],
            "Explorer" => [],
            "Ffmpeg" => [],
            "FileCleaner" => [],
            "FileCreator" => [],
            "GetFileSize" => [],
            "Here" => [],
            "HtmlTemplate" => [],
            "Icons" => [],
            "IndentedLines" => ["Bat", "Bate", "Quoter"],
            "Installer" => ["Bat"],
            "InstantLog" => ["Bat"],
            "JAjaxLoader" => [],
            "JChronometer" => [],
            "JCookie" => [],
            "JDragSlider" => [],
            "JFullScreen" => [],
            "JGoodies" => [],
            "JImageRotator" => [],
            "JInfiniteSlider" => [],
            "JItemSlider" => [],
            "JQuery" => [],
            "JVideoPlayer" => [],
            "JqueryUrlWithDropZone" => ["Jquery"],
            "Kamille" => ["Bat", "Output", "TokenFun"],
            "KamilleWidgets" => ["Kamille"],
            "KaminosUtils" => ["CopyDir", "Output"],
            "Linker" => [],
            "LogSlicer" => ["Bat"],
            "Lys" => [],
            "Meredith" => ["Bat", "QuickPdo", "Tim", "StringFormatter", "SuspiciousException"],
            "MethodInjector" => ["Bat"],
            "MikeMagicTools" => [],
            "MySimpleXmlElement" => [],
            "MysqlTabular" => [],
            "NotationFan" => [],
            "Observer" => [],
            "Ornella" => [],
            "Output" => [],
            "Packer" => ["DirSscanner", "TokenFun"],
            "Pea" => [],
            "PermsHiker" => ["Bat", "DirScanner"],
            "PhpBeast" => ["ArrayToTable"],
            "PhpTemplate" => [],
            "Privilege" => [],
            "Program" => [
                "CommandLineInput",
                "Output",
            ],
            "PublicException" => [],
            "QuickForm" => ["Bat", "QuickPdo"],
            "QuickLog" => ["Bat"],
            "QuickPdo" => [],
            "Quoter" => ["Bat", "WrappedString", "Escaper"],
            "ReflectionRepresentation" => ["VariableToString"],
            "RssUtil" => ["MySimpleXmlElement"],
            "ScreenDebug" => [],
            "SecureImageUploader" => ["Bat", "ThumbnailTools"],
            "SelectChain" => ["Tim"],
            "SequenceMatcher" => [],
            "SitemapBuilderBox" => ["Bat"],
            "SitemapSlicer" => ["Bat", "SitemapBuilderBox"],
            "StringFormatter" => ["ArrayToString", "VariableToString"],
            "SuspiciousException" => [],
            "SvgGridGenerator" => [],
            "TheAnarchist" => [],
            "TheBar" => [],
            "TheScientist" => [],
            "ThumbnailTools" => ["Bat"],
            "Tim" => ["Jquery"],
            "TimeFileUtil" => [],
            "Tiphaine" => [],
            "TokenFun" => ["Bat", "DirScanner"],
            "Tokens" => [],
            "TreeListHelper" => ["Bat"],
            "Umail" => ["DirScanner"],
            "UniqueNameGenerator" => ["Bat"],
            "Updf" => [], // requires https://github.com/tecnickcom/tcpdf
            "Uploader" => [],
            "UploaderHandler" => [],
            "UrlFriendlyListHelper" => ["Bat", "Jquery", "QuickPdo"],
            "VSwitch" => [],
            "VariableToString" => ["ArrayToString", "ReflectionRepresentation"],
            "VideoSubtitles" => [],
            "WrappedString" => ["Escaper"],
            "YouTubeUtils" => [],
            "Zoli" => [],
        ];
    }


    protected function getGithubRepositoryName()
    {
        return "lingtalfi";
    }


    public function getName()
    {
        return "LingUniverseImporter";
    }

    public function getUniverse()
    {
        return "ling";
    }


    protected function getDescription($planetName)
    {
        switch ($planetName) {
            case 'AdminTable':
                return "An object to display administrable list of rows.";
                break;
            case 'ApplicationItemManager':
                return "A planet to help creating certain types of module management console program";
                break;
            case 'ApplicationLog':
                return "Lightweight object to quickly send a message to a log file.";
                break;
            case 'ArrayExport':
                return "This class can export a php array containing closures (aka anonymous functions).";
                break;
            case 'ArrayStore':
                return "Store/retrieve an array to/from a file.";
                break;
            case 'ArrayToString':
                return "Utility to export a php array in various string formats.";
                break;
            case 'ArrayToTable':
                return "Create an html table from a php array.";
                break;
            case 'AssetLoader':
                return "Load assets (js/css) in your html page.";
                break;
            case 'AssetsList':
                return "A helper class to manage assets in your website.";
                break;
            case 'BabyDash':
                return "BabyDash is a notation to write an array in a language independent manner.";
                break;
            case 'BabyYaml':
                return "php implementation of a babyYaml reader.";
                break;
            case 'Bat':
                return "Bat (Basic Tools) is an ensemble of basic tools that one can use to hopefully do a job faster (from the coding point of view, not performance).";
                break;
            case 'Bate':
                return "Bate (Basic Tools Extension) is an extension pack for Bat.";
                break;
            case 'Beauty':
                return "Beauty searches for your test pages and executes them.";
                break;
            case 'BullSheet':
                return "Generate fake data to populate your database.";
                break;
            case 'BumbleBee':
                return "Simple BSR-0 autoloader for a php project.";
                break;
            case 'Colis':
                return "Colis is an input form control connected to a library of user items (videos, images, you decide...).";
                break;
            case 'CommandLineManiac':
                return "Tools for command line scripts written in php.";
                break;
            case 'CommandLineInput':
                return "Api to access command line options and parameters.";
                break;
            case 'ConventionGuy':
                return "Check out my conventions. Tools can use them as references.";
                break;
            case 'ConsoleTool':
                return "A tool to help creating console programs.";
                break;
            case 'CopyDir':
                return "Utility to copy a dir recursively.";
                break;
            case 'Csv':
                return "Csv utility tools.";
                break;
            case 'DirScanner':
                return "Utility to scan a directory recursively and do something on every entry.";
                break;
            case 'DirTransformer':
                return "DirTransformer creates a modified copy of a given directory.";
                break;
            case 'Dreamer':
                return "This is a blog about my dreams.";
                break;
            case 'Escaper':
                return "A tool helping with string escaping.";
                break;
            case 'Explorer':
                return "Tool for installing planets into your application.";
                break;
            case 'Ffmpeg':
                return "A ffmpeg wrapper for php.";
                break;
            case 'FileCleaner':
                return "A helper class to clean a directory based on conditions.";
                break;
            case 'FileCreator':
                return "Create a file, line by line, or block by block.";
                break;
            case 'GetFileSize':
                return "Php service to get the size of the file.";
                break;
            case 'Here':
                return "Helper to represent events on an horizontal timeline.";
                break;
            case 'HtmlTemplate':
                return "A simple template system to work with jquery.";
                break;
            case 'Icons':
                return "Add svg icons to your website.";
                break;
            case 'IndentedLines':
                return "Convert lists in indentedLines format to php arrays.";
                break;
            case 'Installer':
                return "Generic installer for a cms/framework.";
                break;
            case 'InstantLog':
                return "A quick log tool for your php apps.";
                break;
            case 'JAjaxLoader':
                return "A jquery plugin to start/stop an ajax loader.";
                break;
            case 'JChronometer':
                return "A javascript chronometer.";
                break;
            case 'JCookie':
                return "A javascript library to handle cookies.";
                break;
            case 'JDragSlider':
                return "A helper drag function for your sliders.";
                break;
            case 'JFullScreen':
                return "Helper code to fullscreen with javascript.";
                break;
            case 'JGoodies':
                return "Some functions that I found useful while playing with jQuery/javascript.";
                break;
            case 'JImageRotator':
                return "simple image rotator for jquery.";
                break;
            case 'JInfiniteSlider':
                return "Simple jquery infinite (circular) slider.";
                break;
            case 'JItemSlider':
                return "Simple responsive jquery infinite (circular) slider, based on items.";
                break;
            case 'JQuery':
                return "Some compressed Jquery libraries.";
                break;
            case 'JVideoPlayer':
                return "A javascript library to help building a video player.";
                break;
            case 'JqueryUrlWithDropZone':
                return "A jquery based snippet to create a form control consisting of an input text and a dropzone.";
                break;
            case 'Kamille':
                return "My first implementation of the kam framework.";
                break;
            case 'KamilleWidgets':
                return "Widgets for the kamille framework.";
                break;
            case 'KaminosUtils':
                return "A planet to help implementing the kaminos admin system.";
                break;
            case 'Linker':
                return "Tool to help manage application symlinks.";
                break;
            case 'LogSlicer':
                return "Paginate your log file for display.";
                break;
            case 'Lys':
                return "Another infinite scroll jquery plugin.";
                break;
            case 'Meredith':
                return "Php plugin for implementing a crud strategy based on the jquery datatables plugin.";
                break;
            case 'MethodInjector':
                return "A tool for injecting methods from a class to another.";
                break;
            case 'MikeMagicTools':
                return "This is a set of various tools.";
                break;
            case 'MySimpleXmlElement':
                return "Yet another implementation of php's SimpleXmlElement class.";
                break;
            case 'MysqlTabular':
                return "Generate a mysql table with the \"console\" format.";
                break;
            case 'NotationFan':
                return "Planet about user notation.";
                break;
            case 'Observer':
                return "I'm an eye of the universe. I observe patterns emerging while the universe is being created.";
                break;
            case 'Ornella':
                return "Ornella is a notation for replacing {tags} with a customized value.";
                break;
            case 'Output':
                return "Object representing an output.";
                break;
            case 'Packer':
                return "A tool to pack multiple files into one.";
                break;
            case 'Pea':
                return "Php like functions in js.";
                break;
            case 'PermsHiker':
                return "PermsHiker helps migrating permissions from a server to another.";
                break;
            case 'PhpBeast':
                return "This is a php implementation of the Beast component of the Beauty n Beast pattern.";
                break;
            case 'PhpTemplate':
                return "Simple php template system.";
                break;
            case 'Privilege':
                return "Grant privileges to your users.";
                break;
            case 'Program':
                return "A class to help creating console programs";
                break;
            case 'PublicException':
                return "An exception for the gui user.";
                break;
            case 'QuickForm':
                return "Quick and dirty form helper class in php.";
                break;
            case 'QuickLog':
                return "Lightweight object to quickly send a message to a log file.";
                break;
            case 'QuickPdo':
                return "It's a static class that contains basic methods to interact with a mysql database via pdo.";
                break;
            case 'Quoter':
                return "Utilities to manipulate quotes.";
                break;
            case 'ReflectionRepresentation':
                return "Class to help with representation of \\Reflection elements.";
                break;
            case 'RssUtil':
                return "RssUtil contains utilities related to rss.";
                break;
            case 'ScreenDebug':
                return "javascript helper to debug data that change rapidly.";
                break;
            case 'SecureImageUploader':
                return "A simple to use and secure uploader for images in php.";
                break;
            case 'SelectChain':
                return "A simple javascript object to handle a select chain.";
                break;
            case 'SequenceMatcher':
                return "Find/replace a pattern in a sequence of things.";
                break;
            case 'SitemapBuilderBox':
                return "Utilities to create basic sitemaps.";
                break;
            case 'SitemapSlicer':
                return "Generate a sitemap index and its related sitemaps using data from your database.";
                break;
            case 'StringFormatter':
                return "Tool to format string.";
                break;
            case 'SuspiciousException':
                return "This is an interface for the suspicious exception paradigm.";
                break;
            case 'SvgGridGenerator':
                return "Create css grid lines.";
                break;
            case 'TheAnarchist':
                return "Hi, I'm a php developer; this is my blog.";
                break;
            case 'TheBar':
                return "Various discussions about the universe and everything.";
                break;
            case 'TheScientist':
                return "No description, website, or topics provided.";
                break;
            case 'ThumbnailTools':
                return "Tool for manipulating thumbnails.";
                break;
            case 'Tim':
                return "Tim is a simple protocol to help with communication between a client and a server.";
                break;
            case 'TimeFileUtil':
                return "A helper class to get the start date and end date from a directory.";
                break;
            case 'Tiphaine':
                return "Tool for converting a string to a mixed value, using tiphaine notation.";
                break;
            case 'TokenFun':
                return "Tools for playing with php tokens.";
                break;
            case 'Tokens':
                return "Manipulate the tokens inside a file.";
                break;
            case 'TreeListHelper':
                return "Creates an array representing a directory (tree view).";
                break;
            case 'Umail':
                return "A helper class to send mails.";
                break;
            case 'UniqueNameGenerator':
                return "Tool to generate unique names.";
                break;
            case 'Updf':
                return "A helper class to create pdf.";
                break;
            case 'Uploader':
                return "Helps implementing a server side service to handle file uploads.";
                break;
            case 'UploaderHandler':
                return "A tool to help implementing an upload server (with or without chunking).";
                break;
            case 'UrlFriendlyListHelper':
                return "Utility to handle pagination, sort and search in your html lists.";
                break;
            case 'VSwitch':
                return "Simple helper to show/hide portions of your html page.";
                break;
            case 'VariableToString':
                return "Utility to write any php variable to a string representation.";
                break;
            case 'VideoSubtitles':
                return "Tools to work with subtitles.";
                break;
            case 'WrappedString':
                return "Low level utilities to work with wrapped strings.";
                break;
            case 'YouTubeUtils':
                return "Tools to manipulate Youtube Apis.";
                break;
            case 'Zoli':
                return "a modal dialog.";
                break;
            default:
                return "";
                break;
        }
    }

}

}
// ------------------------------

namespace UniverseNaiveImporter\Exception {






class UniverseNaiveImporterException extends \Exception
{

}

}
// ------------------------------

namespace UniverseNaiveImporter {






use Bat\FileSystemTool;
use Output\ProgramOutputInterface;
use UniverseNaiveImporter\Exception\UniverseNaiveImporterException;
use UniverseNaiveImporter\Importer\UniverseImporterInterface;

class UniverseNaiveImporter
{

    /**
     * @var ProgramOutputInterface $output
     */
    private $output;

    /**
     * Safe mode: bool=true
     * In safe mode, all decisions that can potentially do irreversible damage
     * are not taken automatically, but rather delegated to the user.
     *
     * If safe mode is false, all decisions are taken automatically so that the process
     * can finish.
     *
     */
    private $safeMode;
    private $importers;


    public function __construct()
    {
        $this->importers = [];
        $this->safeMode = true;
    }


    public static function create()
    {
        return new static();
    }

    public function setSafeMode($safeMode)
    {
        $this->safeMode = $safeMode;
        return $this;
    }


    public function setOutput(ProgramOutputInterface $output)
    {
        $this->output = $output;
        return $this;
    }

    public function addImporter(UniverseImporterInterface $importer)
    {
        $this->importers[] = $importer;
        return $this;
    }


    /**
     *
     * Returns the list of available planets, grouped by universe.
     *
     * The returned array looks like this:
     *
     * - universeName:
     *      - 0:
     *          - 0: name: string, the name of the planet
     *          - 1: description: string, the description of the planet
     *      - ...
     * - ...
     *
     *
     * Params
     * -------------
     * search:
     *      if null, list all available planets
     * searchOptions:
     *      - universe: string=null, restrict the search to a given universe
     *      - description: bool=false, also searches in the description (by default it only looks up the planet names)
     *
     *
     */
    public function search($search = null, array $searchOptions = null)
    {
        if (null === $searchOptions) {
            $searchOptions = [];
        }
        $searchOptions = array_merge([
            'universe' => null,
            'description' => false,
        ], $searchOptions);
        $universe = $searchOptions['universe'];
        $description = $searchOptions['description'];


        $ret = [];
        foreach ($this->importers as $importer) {

            /**
             * @var UniverseImporterInterface $importer
             */
            $importerUniverse = $importer->getUniverse();
            // universe matches?
            if ($universe !== null && $importerUniverse !== $universe) {
                continue;
            }


            // planets match?
            $planets = $importer->getAvailablePlanets();
            foreach ($planets as $planet) {
                list($name, $desc) = $planet;

                if (
                    null === $search ||
                    false !== mb_stripos($name, $search) ||
                    (true === $description && false !== mb_stripos($desc, $search))
                ) {
                    $ret[$importerUniverse][] = $planet;
                }
            }
        }
        return $ret;
    }

    /**
     * @return array, list of all available full planet names
     */
    public function getAllPlanets($universe = null)
    {
        $ret = [];
        foreach ($this->importers as $importer) {
            /**
             * @var UniverseImporterInterface $importer
             */
            $planets = $importer->getAvailablePlanets();
            $importerUniverse = $importer->getUniverse();
            if (null === $universe || $universe === $importerUniverse) {
                foreach ($planets as $planet) {
                    list($name, $desc) = $planet;
                    $fullPlanetName = $importerUniverse . "." . $name;
                    $ret[] = $fullPlanetName;
                }
            }
        }
        return $ret;
    }

    /**
     * Import one or more planet.
     *
     *
     *
     * planets: the full planet name, or an array of full planet names.
     *              - fullPlanetName: (<universe> <.>) <planetName>
     * force:
     *      if false, skip the planet if it already exists
     *      if true, remove the planet and re-import it
     *
     * localUniverse:
     *      if null, will use the importer to import
     *      if set to the local universe path's planetsDir, will try to create symlinks to this local universe
     *
     *
     */
    public function import($planetsDir, $planets, $force = false, $localUniverse = null)
    {
        $prefix = $this->getPrefix();
        $output = $this->output;
        if (!is_array($planets)) {
            $planets = [$planets];
        }

        // list all planets and dependencies
        // if force, remove all planets
        // import all planets one by one


        // list all planets and dependencies, array of planet => oImporter
        $planet2Importers = $this->getPlanet2Importers($planets);

        // if force, remove all planets
        if (true === $force) {
            foreach ($planet2Importers as $planet => $importer) {
                $planetDir = $planetsDir . "/" . $planet;
                if (is_link($planetDir)) {
                    unlink($planetDir);
                } elseif (is_dir($planetDir)) {
                    FileSystemTool::remove($planetDir);
                }
            }
        }


        // import all planets one by one
        foreach ($planet2Importers as $planet => $importer) {
            /**
             * @var UniverseImporterInterface $importer
             */
            $planetDir = $planetsDir . "/" . $planet;
            if (is_dir($planetDir)) {
                $output->success($prefix . "Planet $planet already imported");
            } else {
                // it will skip if the planet already exist
                if (null === $localUniverse) {
                    $importer->import($planet, $planetsDir);
                    $output->success($prefix . "Planet $planet imported");
                } else {
                    if (is_dir($localUniverse)) {
                        $localPlanetDir = $localUniverse . "/" . $planet;
                        $planetDir = $planetsDir . "/" . $planet;
                        if (is_dir($localPlanetDir)) {
                            if (true === symlink($localPlanetDir, $planetDir)) {
                                $output->success($prefix . "Planet $planet symlinked from local repository");
                            } else {
                                $output->error($prefix . "Cannot create symlink for planet $planet, try with the -f flag");
                            }
                        } else {
                            $output->error("Planet $planet not found in local repository ($localUniverse)");
                        }
                    } else {
                        throw new UniverseNaiveImporterException("directory does not exist: $localUniverse");
                    }
                }
            }
        }
    }

    public function bigbangify($planetsDir)
    {

        $bigbangString = <<<'BIGBANG'
<?php



//------------------------------------------------------------------------------/
// THIS IS BIG BANG SCRIPT, from whence the universe can be used
//------------------------------------------------------------------------------/
use BumbleBee\Autoload\ButineurAutoloader;


require_once __DIR__ . '/BumbleBee/Autoload/BeeAutoloader.php';
require_once __DIR__ . '/BumbleBee/Autoload/ButineurAutoloader.php';



if (!isset($__butineurStart)) {
    $__butineurStart = true;
}

ButineurAutoloader::getInst()
    ->addLocation(__DIR__);
// ->addLocation(__DIR__ . "/myclasses") // we could use multiple directories if needed
//
//
if (true === $__butineurStart) {
    ButineurAutoloader::getInst()->start();
}

//------------------------------------------------------------------------------/
// BONUS FUNCTIONS, SO HANDFUL... (a huge time saver in the end)
//------------------------------------------------------------------------------/
if (!function_exists('a')) {
    function a()
    {
        foreach (func_get_args() as $arg) {
            ob_start();
            var_dump($arg);
            $output = ob_get_clean();
            if ('1' !== ini_get('xdebug.default_enable')) {
                $output = preg_replace("!\]\=\>\n(\s+)!m", "] => ", $output);
            }
            if ('cli' === PHP_SAPI) {
                echo $output;
            }
            else {
                echo '<pre>' . $output . '</pre>';
            }
        }
    }
    function az()
    {
        call_user_func_array('a', func_get_args());
        exit;
    }
}
BIGBANG;


        $bigbangFile = $planetsDir . "/bigbang.php";

        $prefix = $this->getPrefix();
        $force = false;
        $output = $this->output;
        if (file_exists($bigbangFile) && false === $force) {
            $output->success($prefix . 'Bigbang script is already in place');
        } else {
            if (false !== file_put_contents($bigbangFile, $bigbangString)) {
                $output->success($prefix . 'Bigbang script has been created successfully');
            } else {
                $output->error($prefix . "Bigbang script couldn't be created");
            }
        }
    }

    //--------------------------------------------
    //
    //--------------------------------------------
    private function getPlanet2Importers(array $planets)
    {
        $ret = [];
        foreach ($planets as $planet) {
            $universe = null;
            $p = explode('.', $planet, 2);
            if (2 === count($p)) {
                $universe = $p[0];
                $planet = $p[1];
            }
            $importerFound = false;

            // find the planet's importer
            foreach ($this->importers as $importer) {

                /**
                 * @var UniverseImporterInterface $importer
                 */
                $importerUniverse = $importer->getUniverse();
                // universe matches?
                if ($universe !== null && $importerUniverse !== $universe) {
                    continue;
                }
                if (true === $importer->canImport($planet)) {
                    $importerFound = true;
                    $ret[$planet] = $importer;
                }
            }

            if (false === $importerFound) {
                $msg = "No importer can import planet $planet";
                if (true === $this->safeMode) {
                    throw new UniverseNaiveImporterException($msg);
                } else {
                    $this->output->error($this->getPrefix() . $msg);
                }
            }
        }
        return $ret;
    }

    private function getPrefix()
    {
        return '* ';
    }
}

}
// ------------------------------

namespace UniverseNaiveImporter\Helper {






use Output\ProgramOutputInterface;

class CliHelper
{
    public static function printSearchResults(ProgramOutputInterface $output, $search, array $results, $showDescription = false)
    {
        if (null !== $search) {
            $search = strtolower(trim($search));
        }

        foreach ($results as $universe => $planets) {
            $output->notice("universe $universe:");


            foreach ($planets as $planetInfo) {

                if (null !== $search) {
                    $planet = self::highlight($planetInfo[0], $search);
                    $description = self::highlight($planetInfo[1], $search);
                } else {
                    list($planet, $description) = $planetInfo;
                }

                if (false === $showDescription) {
                    $output->notice("- " . $planet);
                } else {
                    $output->info("- " . $planet);
                    $output->notice(self::indent($description));
                }
            }
        }
    }


    private static function indent($text)
    {
        $nbSpaces = 4;
        $p = explode(PHP_EOL, $text);
        $sp = str_repeat(" ", $nbSpaces);
        return $sp . implode(PHP_EOL . $sp, $p);
    }

    private static function highlight($text, $search)
    {
        $ret = $text;
        $positions = [];


        $offset = 0;
        $len = mb_strlen($search);
        while (false !== ($pos = mb_stripos($text, $search, $offset))) {
            $positions[] = $pos;
            $offset = $pos + 1;
        }
        rsort($positions);

        if (count($positions) > 0) {
            foreach ($positions as $pos) {
                $s = "";
                $s .= mb_substr($ret, 0, $pos);
                $s .= "\033[1;37m\033[44m" . mb_substr($text, $pos, $len) . "\033[0m";
//                        $s .= "[" . mb_substr($ret, $pos, $len) . "]";
                $s .= mb_substr($ret, $pos + $len);
                $ret = $s;
            }


        }
        return $ret;
    }
}

}
// ------------------------------

namespace LocalUniverse {






/**
 * This class allows to get/set the value of the local universe path.
 * It uses a simple text file as the storage.
 * The text file is created next to the current script location (which is presumed to be next to the uni script.
 */
class LocalUniverse
{


    public static function create()
    {
        return new static();
    }

    public function setLocalUniversePath($path)
    {
        if (false !== file_put_contents($this->getStorageFile(), $path)) {
            return true;
        }
        return false;
    }


    public function getLocalUniversePath()
    {
        $file = $this->getStorageFile();
        if (file_exists($file)) {
            return trim(file_get_contents($file));
        }
        return false;
    }

    //--------------------------------------------
    //
    //--------------------------------------------
    private function getStorageFile()
    {
        return __DIR__ . "/local-universe-path.txt";
    }
}

}
// ------------------------------



//--------------------------------------------
// MANUALLY EDIT BELOW THIS LINE, BUT ABOVE THIS LINE IS AUTOMATICALLY GENERATED
/**
 * See the packed.php script for more info
 */
//--------------------------------------------
namespace {

    use BumbleBee\Autoload\ButineurAutoloader;
    use LocalUniverse\LocalUniverse;
    use Output\ProgramOutput;
    use Tools\CleanerTool;
    use Tools\SymlinkDirTool;
    use UniverseNaiveImporter\Helper\CliHelper;
    use UniverseNaiveImporter\Importer\LingUniverseImporter;
    use UniverseNaiveImporter\UniverseNaiveImporter;


    if (!function_exists('a')) {
        function a()
        {
            foreach (func_get_args() as $arg) {
                ob_start();
                var_dump($arg);
                $output = ob_get_clean();
                if ('1' !== ini_get('xdebug.default_enable')) {
                    $output = preg_replace("!\]\=\>\n(\s+)!m", "] => ", $output);
                }
                if ('cli' === PHP_SAPI) {
                    echo $output;
                } else {
                    echo '<pre>' . $output . '</pre>';
                }
            }
        }

        function az()
        {
            call_user_func_array('a', func_get_args());
            exit;
        }
    }


    function getHelpText()
    {
        return <<<HELP
\e[34m        
Usage
-------
uni import {fullPlanetName}                     # import one planet and dependencies, but skip already existing planet(s)/dependencies. You need to be in your application directory first
uni import -f {fullPlanetName}                  # remove the planet and its dependencies, then re-import them. You need to be in your application directory first
uni import _all_ {universe}?                    # import all planets and dependencies, but skip already existing planet(s)/dependencies. You need to be in your application directory first
uni import -f _all_ {universe}?                 # remove all planets and dependencies, then re-import them one by one. You need to be in your application directory first

uni importp {fullPlanetName}                    # like import, but in the import in the current directory (import in place) rather than in the planets directory
uni importp -f {fullPlanetName}                 # like import, but in the import in the current directory (import in place) rather than in the planets directory
uni importp _all_ {universe}?                   # like import, but in the import in the current directory (import in place) rather than in the planets directory
uni importp -f _all_ {universe}?                # like import, but in the import in the current directory (import in place) rather than in the planets directory

uni list {universe}?                            # list available planets
uni listd {universe}?                           # list available planets, with description

uni search {term} {universe}?                   # search a term in available planets
uni searchd {term} {universe}?                  # search a term in available planets and description

uni getlocaluniverse                            # get the local universe path
uni setlocaluniverse {localUniversePath}        # set the local universe path

uni tosymlink                                   # converts the planets of the application to symlinks (to the local universe)
uni todir                                       # converts the planets of the application to directories (copied from the local universe)

uni clean                                       # removes the .git, .gitignore, .idea and .DS_Store files at the top level of your application's planet directories, but does nothing if the planet is a symlink
uni cleanr                                      # removes the .git, .gitignore, .idea and .DS_Store files from the planet directories recursively, but does nothing if the planet is a symlink


For instance: 
    uni import Bat
    uni import ling.Bat
    uni import -f Bat
    uni import -f _all_
    uni import -f _all_ ling
    uni list
    uni list ling
    uni listd
    uni listd ling
    uni search ba
    uni search ba ling
    uni searchd ba 
    uni searchd ba ling
    uni setlocaluniverse /myphp/universe
    uni getlocaluniverse
    uni tosymlink
    uni todir
    uni clean
    uni cleanr
    
    
Options
-------------
-f: force overwriting of existing planets and dependencies.
    
    
Nomenclature
--------------
- fullPlanetName: (<universe> <.>) <planetName>
    

\e[0m
HELP;
    }


    ini_set("display_errors", 1);
    $devMode = false; // mode for ling, while developing
    if (true === $devMode) {
        require_once __DIR__ . "/pprivate/BumbleBee/Autoload/BeeAutoloader.php";
        require_once __DIR__ . "/pprivate/BumbleBee/Autoload/ButineurAutoloader.php";
        ButineurAutoloader::getInst()
            ->addLocation(__DIR__ . "/pprivate")
            ->start();
    }


    $output = ProgramOutput::create();
    $appDir = getcwd();
    $planetsRelativePath = 'planets';
    $localUniversePlanetsRelativePath = 'planets';

    $force = false;
    foreach ($argv as $k => $arg) {
        if ('-f' === $arg) {
            $force = true;
            unset($argv[$k]);
            $argv = array_merge($argv);
        }
    }


    $uni = UniverseNaiveImporter::create()
        ->setOutput($output)
        ->addImporter(LingUniverseImporter::create());


    try {
        //--------------------------------------------
        // IMPORT
        //--------------------------------------------
        if (array_key_exists(1, $argv) &&
            ('import' === $argv[1] || 'importp' === $argv[1]) &&
            array_key_exists(2, $argv)
        ) {


            $what = $argv[2];

            $universe = null;
            if (array_key_exists(3, $argv)) {
                $universe = $argv[3];
            }


            $createBigBang = true;
            if ('importp' === $argv[1]) {
                $planetsDir = $appDir;
                $createBigBang = false;
            } else {
                $planetsDir = $appDir . "/" . $planetsRelativePath;
            }
            if (false === file_exists($planetsDir)) {
                @mkdir($planetsDir, 0777, true);
            }


            if (file_exists($planetsDir)) {
                if ('_all_' === $what) {
                    $what = $uni->getAllPlanets($universe);
                }
                $uni->import($planetsDir, $what, $force);
                if (true === $createBigBang) {
                    $uni->bigbangify($planetsDir);
                }

            } else {
                $output->error("Cannot create the planets directory: $planetsDir");
            }

        }
        //--------------------------------------------
        // LIST
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) &&
            (
                'list' === $argv[1] ||
                'listd' === $argv[1]
            )
        ) {
            $universe = null;
            if (array_key_exists(2, $argv)) {
                $universe = $argv[2];
            }
            $description = ('listd' === $argv[1]);
            $results = $uni->search(null, [
                'universe' => $universe,
                'description' => false,
            ]);
            CliHelper::printSearchResults($output, null, $results, $description);
        }
        //--------------------------------------------
        // SEARCH
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) &&
            (
                'search' === $argv[1] ||
                'searchd' === $argv[1]
            )
            && array_key_exists(2, $argv)
        ) {
            $search = $argv[2];
            $universe = null;
            if (array_key_exists(3, $argv)) {
                $universe = $argv[3];
            }
            $description = ('searchd' === $argv[1]);
            $results = $uni->search($search, [
                'universe' => $universe,
                'description' => $description,
            ]);
            CliHelper::printSearchResults($output, $search, $results, $description);
        }
        //--------------------------------------------
        // SET/GET LOCAL UNIVERSE
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) && 'setlocaluniverse' === $argv[1] && array_key_exists(2, $argv)) {
            $path = $argv[2];
            if (true === LocalUniverse::create()->setLocalUniversePath($path)) {
                $output->success("local path successfully set");
            } else {
                $output->error("local path couldn't be set");
            }

        } elseif (array_key_exists(1, $argv) && 'getlocaluniverse' === $argv[1]) {
            if (false !== ($path = LocalUniverse::create()->getLocalUniversePath())) {
                $output->notice($path);
            } else {
                $output->error("local path couldn't be retrieved. Please use the setlocaluniverse command first");
            }

        }
        //--------------------------------------------
        // TO SYMLINK, TO DIR
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) &&
            ('tosymlink' === $argv[1] || 'todir' === $argv[1])
        ) {


            if (false !== ($path = LocalUniverse::create()->getLocalUniversePath())) {

                $mode = ('tosymlink' === $argv[1]) ? "symlink" : "dir";


                $localUniversePlanetsDir = $path . "/" . $localUniversePlanetsRelativePath;
                $appDir = getcwd();
                $targetPlanetsDir = $appDir . "/" . $planetsRelativePath;
                if (is_dir($localUniversePlanetsDir)) {
                    if (is_dir($targetPlanetsDir)) {
                        SymlinkDirTool::create()->setOutput($output)->convert($mode, $targetPlanetsDir, $localUniversePlanetsDir);
                    } else {
                        $output->error("The application planets directory doesn't exist. Please create it first, then re-execute this command. Expected path: $targetPlanetsDir");
                    }
                } else {
                    $output->error("The local universe planets dir was not found: $localUniversePlanetsDir. Have you set it with setlocaluniverse?");
                }
            } else {
                $output->error("local path couldn't be retrieved. Please use the setlocaluniverse command first");
            }

        }
        //--------------------------------------------
        // CLEAN
        //--------------------------------------------
        elseif (array_key_exists(1, $argv) &&
            (
                'clean' === $argv[1] ||
                'cleanr' === $argv[1]
            )
        ) {
            $targetPlanetsDir = $appDir . "/" . $planetsRelativePath;

            if (is_dir($targetPlanetsDir)) {
                $recursive = false;
                if ('cleanr' === $argv[1]) {
                    $recursive = true;
                }
                CleanerTool::create()->clean($targetPlanetsDir, $recursive);
            } else {
                $output->error("The application planets directory doesn't exist. Please create it first, then re-execute this command. Expected path: $targetPlanetsDir");
            }
        } else {
            $output->notice("");
            $output->error("Invalid arguments");
            echo getHelpText();
        }
    } catch (\Exception $e) {
        $output->error("Exception: " . $e->getMessage());
    }
}



